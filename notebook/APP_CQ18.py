# -*- coding: utf-8 -*-
"""APP_CQ18.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AKPoUeKqC21NIDrRL9G--pW2APTvzp1L

***Liên kết Google Colab với Google Drive***
"""

from google.colab import drive
drive.mount('/content/drive')

"""***Truy cập vào thư mục content của Google Colab***"""

import os
os.chdir("/content")

#import os
#import glob
#fileList = glob.glob('/content/drive/MyDrive/T*.jpg')
#print("Number of files: ",len(fileList))
    
#for filePath in fileList:
  #try:
    #os.remove(filePath)
  #except:
    #print("Error while deleting file : ", filePath)

"""***Giải nén file zip từ Google Drive***"""

!unzip /content/drive/MyDrive/APP-CQ18/plant-pathology-2020-fgvc7.zip

"""***Nhập vào các thư viện cần thiết***"""

import glob 
import cv2 
from google.colab.patches import cv2_imshow

import pandas as pd
import matplotlib.pyplot as plt

"""***Lưu các hình ảnh train và test vào biến mới***"""

test_dir = glob.glob('/content/images/Test*.jpg')  
train_dir = glob.glob('/content/images/Train*.jpg')

train_dir = sorted(train_dir, key = lambda x: (len(x), x))
test_dir = sorted(test_dir, key = lambda x: (len(x), x))

test = [] 
train = [] 
scale = 0.5

for f in test_dir: 
  img = cv2.imread(f)
  width = int(img.shape[1] * scale)
  height = int(img.shape[0] * scale)
  dim = (width, height)
  resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)
  test.append(resized) 

for f in train_dir: 
  img = cv2.imread(f)
  width = int(img.shape[1] * scale)
  height = int(img.shape[0] * scale)
  dim = (width, height)
  resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)
  train.append(resized)

len(test), len(train)

"""***Khám phá dữ liệu file csv***"""

train_csv = pd.read_csv('train.csv')
test_csv = pd.read_csv('test.csv')
sam_sub_csv = pd.read_csv('sample_submission.csv')

train_csv.head(3), test_csv.head(3), sam_sub_csv.head(3)

train_csv.info()

"""- Dữ liệu huấn luyện gồm có 1821 hình ảnh và nhãn của chúng. 
- Không có dữ liệu rỗng
- Ý nghĩa các cột:
    - `image_id`: tên file hình ảnh
    - `healthy`: 1 nếu cây khỏe mạnh, 0 nếu ngược lại
    - `multiple_diseases`: 1 nếu cây có nhiều bệnh cùng lúc, 0 nếu ngược lại
    - `rust`: 1 nếu cây bị bệnh rust, 0 nếu ngược lại 
    - `scab`: 1 nếu cây bị bệnh scab, 0 nếu ngược lại
"""

train_csv = train_csv.drop('image_id', axis = 1)
train_csv.value_counts()

fig, axes = plt.subplots(1,1)

not_healthy = train_csv.loc[(train_csv.healthy == 0), ['multiple_diseases', 'rust', 'scab']]
pd.Series(not_healthy.sum()).plot.bar(title = 'Not healthy', color = 'red')
plt.xticks(rotation = 0)

fig, axes = plt.subplots(1,1)

healthy = train_csv.loc[(train_csv.healthy == 1), ['healthy']]
pd.Series(healthy.sum()).plot.bar(title = 'Healthy', color = 'green')
plt.xticks(rotation = 0)

"""- Mỗi hình ảnh chỉ thuộc về một loại duy nhất trong tập {healthy, multiple_diseases, rust, scab}
- Lượng hình ảnh của mỗi loại trong {rust, scab, healthy} khá tương đồng, tuy nhiên lượng hình ảnh của multiple_diseases ít hơn hẳn

***Chuẩn bị dữ liệu file csv***
"""

train_csv = pd.read_csv('train.csv')
test_csv = pd.read_csv('test.csv')
sam_sub_csv = pd.read_csv('sample_submission.csv')

train_csv.head(3), test_csv.head(3), sam_sub_csv.head(3)

train_label = train_csv.melt(['image_id'])
train_label.drop(index=train_label[train_label['value'] == 0].index, inplace=True)
train_label.head(3)

train_csv = train_csv.merge(train_label, on='image_id')
train_csv.drop(columns=['value'], inplace=True)
train_csv.rename(columns={'variable': 'class'}, inplace=True)
train_csv.head(3)

from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()
train_csv['label'] = le.fit_transform(train_csv['class'])
train_csv.head(3)

train_csv['image'] = train
test_csv['image'] = test

train_csv.head(3), test_csv.head(3)

healthy = train_csv[train_csv.healthy==1]['image']
multiple_diseases = train_csv[train_csv.multiple_diseases==1]['image']
rust = train_csv[train_csv.rust==1]['image']
scab = train_csv[train_csv.scab==1]['image']

list_healthy = list(healthy)
list_multiple_diseases = list(multiple_diseases)
list_rust = list(rust)
list_scab = list(scab)

"""**Tài liệu tham khảo** https://www.geeksforgeeks.org/image-processing-without-opencv-python/"""

import numpy as np

def resize(image, scale_height, scale_width): # resize image function with scale is in range (0, 1)
  height, width, channel = image.shape[:] # get height, width, channel in shape of image

  new_height = int(height * scale_height) # new height after height scaled
  new_width = int(width * scale_width) # new width after width scaled

  array_channel = []
  array_height = []
  array_width = []

  for i in range(channel):
    array_channel.append(np.float64(0))
  for j in range(new_width):
    array_width.append(array_channel)
  for k in range(new_height):
    array_height.append(array_width)

  new_image = np.array(array_height)
  
  #new_image = np.zeros([new_height, new_width, channel]) # create matrix has 0 values 
  # with new height (vertical), new width (horizontal) 
  # and channel with 3 attribute [R, G, B] values

  for i in range(new_height): # iterate vertical pixel in new height
   for j in range(new_width): # iterate horizontal pixel in new width
    new_image[i, j] = image[int(i / scale_height), int(j / scale_width)] # root image has bigger size than new image, pixels in root image
    # have smaller size than new image. Because scale is in range (0, 1) so that pixels divide to scale

  return new_image # return new image

def gray(image): # gray image function
  height, width, channel = image.shape[:] # get height, width, channel in shape of image 

  array_channel = []
  array_height = []
  array_width = []

  for i in range(channel):
    array_channel.append(np.float64(0))
  for j in range(width):
    array_width.append(array_channel)
  for k in range(height):
    array_height.append(array_width)

  new_image = np.array(array_height)

  #new_image = np.zeros([height, width, channel]) # create matrix has 0 values 
  # with height (vertical), width (horizontal) 
  # and channel with 3 attribute [R, G, B] values

  for i in range(height): # iterate vertical pixel in height
   for j in range(width): # iterate horizontal pixel in width
    list_rgb = [float(image[i][j][0]), float(image[i][j][1]), float(image[i][j][2])] # list of red, green and blue pixels
    average_value = (list_rgb[0] + list_rgb[1] + list_rgb[2]) / len(list_rgb) # calculate mean of elements of list rgb
    new_image[i][j][0] = average_value # set red pixels = average value
    new_image[i][j][1] = average_value # set green pixels = average value
    new_image[i][j][2] = average_value # set blue pixels = average value
    
  return new_image # return new image

def blur(image): # blur image function
  height, width, channel = image.shape[:] # get height, width, channel in shape of image 

  array_channel = []
  array_height = []
  array_width = []

  for i in range(channel):
    array_channel.append(np.float64(0))
  for j in range(width):
    array_width.append(array_channel)
  for k in range(height):
    array_height.append(array_width)

  new_image = np.array(array_height)

  #new_image = np.zeros([height, width, channel]) # create matrix has 0 values 
  # with height (vertical), width (horizontal) 
  # and channel with 3 attribute [R, G, B] values
  
  #kernel_filter = np.ones((3, )) / 3
  for i in range(height - 1): # iterate vertical pixel in height
   for j in range(width - 1): # iterate horizontal pixel in width
    for k in [0, 1, 2]:
      list_nearest = [float(image[i + 1, j + 1][k]), float(image[i - 1, j - 1][k]), float(image[i, j + 1][k]), float(image[i, j - 1][k]), \
                      float(image[i + 1, j][k]), float(image[i - 1, j][k]), float(image[i + 1, j - 1][k]), float(image[i - 1, j + 1][k])]
                
      #new_image[i, j][k] = np.mean(list_nearest)
                    
      new_image[i, j][k] = (float(image[i + 1, j + 1][k]) + float(image[i - 1, j - 1][k]) + float(image[i, j + 1][k]) + float(image[i, j - 1][k]) + \
                      float(image[i + 1, j][k]) + float(image[i - 1, j][k]) + float(image[i + 1, j - 1][k]) + float(image[i - 1, j + 1][k])) / (len(list_nearest))

      #new_image[i, j][k] = (4*image[i,j][k] + image[i-1,j][k] + image[i+1,j][k] + image[i,j-1][k] + image[i,j+1][k])/8.0  

  return new_image #return new image

#test resize, gray, blur image function
cv2_imshow(resize(gray(train[100]), 0.5, 0.65))
cv2_imshow(resize(train[100], 0.5, 0.65))
cv2_imshow(resize(blur(train[100]), 0.5, 0.65))

from numba import njit, prange

@njit(nopython = True, nogil = True, parallel = True, fastmath = True, cache = True, forceobj = True, looplift = True)
def resize_parallel(image, scale_height, scale_width): # resize image function with scale is in range (0, 1)
  height, width, channel = image.shape[:] # get height, width, channel in shape of image (height, width, channel)

  new_height = int(height * scale_height) # new height after height scaled
  new_width = int(width * scale_width) # new width after width scaled
  
  array_channel = []
  array_height = []
  array_width = []

  for i in prange(channel):
    array_channel.append(np.float64(0))
  for j in range(new_width):
    array_width.append(array_channel)
  for k in range(new_height):
    array_height.append(array_width)

  new_image = np.array(array_height)

  #new_image = np.zeros([new_height, new_width, channel]) # create matrix has 0 values 
  # with new height (vertical), new width (horizontal) 
  # and channel with 3 attribute [R, G, B] values

  for i in prange(new_height): # iterate vertical pixel in new height
   for j in prange(new_width): # iterate horizontal pixel in new width
    new_image[i, j]= image[int(i / scale_height), int(j / scale_width)] # root image has bigger size than new image, pixels in root image
    # have smaller size than new image. Because scale is in range (0, 1) so that pixels divide to scale

  return new_image # return new image

@njit(nopython = True, nogil = True, parallel = True, fastmath = True, cache = True, forceobj = True, looplift = True)
def gray_parallel(image): # gray image function
  height, width, channel = image.shape[:] # get height, width, channel in shape of image 

  array_channel = []
  array_height = []
  array_width = []

  for i in prange(channel):
    array_channel.append(np.float64(0))
  for j in range(width):
    array_width.append(array_channel)
  for k in range(height):
    array_height.append(array_width)

  new_image = np.array(array_height)

  #new_image = np.zeros([height, width, channel]) # create matrix has 0 values 
  # with height (vertical), width (horizontal) 
  # and channel with 3 attribute [R, G, B] values

  for i in prange(height): # iterate vertical pixel in height
   for j in prange(width): # iterate horizontal pixel in width
    list_rgb = [float(image[i][j][0]), float(image[i][j][1]), float(image[i][j][2])] # list of red, green and blue pixels
    average_value = (list_rgb[0] + list_rgb[1] + list_rgb[2]) / len(list_rgb) # calculate mean of elements of list rgb
    new_image[i][j][0] = average_value # set red pixels = average value
    new_image[i][j][1] = average_value # set green pixels = average value
    new_image[i][j][2] = average_value # set blue pixels = average value
    
  return new_image # return new image

@njit(nopython = True, nogil = True, parallel = True, fastmath = True, cache = True, forceobj = True, looplift = True)
def blur_parallel(image): # blur image function
  height, width, channel = image.shape[:] # get height, width, channel in shape of image 

  array_channel = []
  array_height = []
  array_width = []

  for i in prange(channel):
    array_channel.append(np.float64(0))
  for j in range(width):
    array_width.append(array_channel)
  for k in range(height):
    array_height.append(array_width)

  new_image = np.array(array_height)

  #new_image = np.zeros([height, width, channel]) # create matrix has 0 values 
  # with height (vertical), width (horizontal) 
  # and channel with 3 attribute [R, G, B] values
  
  #kernel_filter = np.ones((3, )) / 3
  for i in prange(height - 1): # iterate vertical pixel in height
   for j in prange(width - 1): # iterate horizontal pixel in width
    for k in [0, 1, 2]:
      list_nearest = [float(image[i + 1, j + 1][k]), float(image[i - 1, j - 1][k]), float(image[i, j + 1][k]), float(image[i, j - 1][k]), \
                      float(image[i + 1, j][k]), float(image[i - 1, j][k]), float(image[i + 1, j - 1][k]), float(image[i - 1, j + 1][k])]
                
      #new_image[i, j][k] = np.mean(list_nearest)
                    
      new_image[i, j][k] = (float(image[i + 1, j + 1][k]) + float(image[i - 1, j - 1][k]) + float(image[i, j + 1][k]) + float(image[i, j - 1][k]) + \
                      float(image[i + 1, j][k]) + float(image[i - 1, j][k]) + float(image[i + 1, j - 1][k]) + float(image[i - 1, j + 1][k])) / (len(list_nearest))

      #new_image[i, j][k] = (4*image[i,j][k] + image[i-1,j][k] + image[i+1,j][k] + image[i,j-1][k] + image[i,j+1][k])/8.0  

  return new_image #return new image

# Commented out IPython magic to ensure Python compatibility.
# %%time
# resize(cv2.imread(train_dir[150]), 0.4, 0.6)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# resize_parallel(cv2.imread(train_dir[150]), 0.4, 0.6)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# gray(cv2.imread(train_dir[150]))

# Commented out IPython magic to ensure Python compatibility.
# %%time
# gray_parallel(cv2.imread(train_dir[150]))

# Commented out IPython magic to ensure Python compatibility.
# %%time
# blur(cv2.imread(train_dir[150]))

# Commented out IPython magic to ensure Python compatibility.
# %%time
# blur_parallel(cv2.imread(train_dir[150]))

"""***Mô hình hóa dữ liệu với XGBoost***"""

#import xgboost as xgb

#param = {'max_depth':2, 'eta':1, 'objective':'binary:logistic'}
#model = xgb.train(param, train_csv, 5)